{"ast":null,"code":"import { compareAsc, format } from \"date-fns\";\n\nrequire('dotenv').config();\n\nexport const FORMAT_TIME_SCORE = 'm ss';\nexport const FORMAT_DATE = 'yyyy-MM-dd';\ndebugger;\nconst PORT = process.env.PORT || '3001';\nconst API = process.env.NODE_ENV === 'production' ? 'https://crossword.herokuapp.com' : `http://localhost:${PORT}`;\nexport async function doFetch(method, endpoint, body) {\n  try {\n    const response = await fetch(`${API}${endpoint}`, {\n      method,\n      body: body && JSON.stringify(body),\n      headers: {\n        'content-type': 'application/json',\n        accept: 'application/json'\n      }\n    });\n    return {\n      response: await response.json(),\n      error: null\n    };\n  } catch (error) {\n    return {\n      response: null,\n      error: error\n    };\n  }\n} //return function returns positive number if score1 beats score2, 0 if scores are equal, negative \n//number otherwise\n\nexport const scoreComparator = (scoreDirectionUp, scoreType) => {\n  return function (score1, score2) {\n    debugger;\n\n    if (scoreType === scoreTypes.POINTS) {\n      return scoreDirectionUp ? score1 - score2 : score2 - score1;\n    } else {\n      const time1 = score1.replace(' ', '');\n      const time2 = score2.replace(' ', '');\n      return scoreDirectionUp ? time1 - time2 : time2 - time1;\n    }\n  };\n}; //returns a map with key as a date string and value as a Map with key: leagueUser id and \n// value: the users best score for that date \n\nexport const getAllDatesWithScore = (league, comparator) => {\n  if (!league) return null;\n  const dates = new Map();\n  const leagueUsers = [...league.leagueUsers];\n  leagueUsers.forEach(leagueUser => leagueUser.scores.forEach(score => {\n    if (dates.has(score.date)) {\n      return false;\n    } else {\n      dates.set(score.date, null);\n      return true;\n    }\n  }));\n  leagueUsers.forEach(leagueUser => {\n    leagueUser.scores.forEach(score => {\n      let userMap = dates.get(score.date);\n\n      if (userMap === null) {\n        userMap = new Map();\n        userMap.set(leagueUser.id, score);\n        dates.set(score.date, userMap);\n      } else {\n        const bestScore = userMap.get(leagueUser.id);\n        debugger;\n\n        if (!bestScore || comparator(score.value, bestScore.value) > 0) {\n          userMap.set(leagueUser.id, score);\n        }\n      }\n    });\n  });\n  return dates;\n}; //returns foramtted date without adjusting for time zone (date-fns does this automatically)\n\nexport function formatIgnoreTimeZone(date, formatString) {\n  const dateNew = new Date(date.valueOf() + date.getTimezoneOffset() * 60 * 1000);\n  return format(dateNew, formatString);\n}\nexport const scoreTypes = {\n  POINTS: 'points',\n  TIME: 'time'\n};\nexport function parseScore(scoreString) {\n  if (!scoreString) return null;\n  const toArr = scoreString.trim().split(' ');\n\n  if (toArr.length === 1) {\n    return toArr[0];\n  } else if (toArr.length === 2) {\n    return toArr[0] + ':' + toArr[1];\n  }\n\n  return null;\n}","map":{"version":3,"sources":["/Users/bensmith/workspace/projects/crossword-league/react/src/Util/Util.jsx"],"names":["compareAsc","format","require","config","FORMAT_TIME_SCORE","FORMAT_DATE","PORT","process","env","API","NODE_ENV","doFetch","method","endpoint","body","response","fetch","JSON","stringify","headers","accept","json","error","scoreComparator","scoreDirectionUp","scoreType","score1","score2","scoreTypes","POINTS","time1","replace","time2","getAllDatesWithScore","league","comparator","dates","Map","leagueUsers","forEach","leagueUser","scores","score","has","date","set","userMap","get","id","bestScore","value","formatIgnoreTimeZone","formatString","dateNew","Date","valueOf","getTimezoneOffset","TIME","parseScore","scoreString","toArr","trim","split","length"],"mappings":"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","sourcesContent":["import { compareAsc, format } from \"date-fns\";\nrequire('dotenv').config();\n\n\nexport const FORMAT_TIME_SCORE = 'm ss';\nexport const FORMAT_DATE = 'yyyy-MM-dd';\ndebugger;\nconst PORT = process.env.PORT || '3001';\nconst API =  process.env.NODE_ENV === 'production' ? 'https://crossword.herokuapp.com' \n                                                   : `http://localhost:${PORT}`;\n\nexport async function doFetch(method, endpoint, body) {\n    try {\n      const response = await fetch(`${API}${endpoint}`, {\n        method,\n        body: body && JSON.stringify(body),\n        headers: {\n          'content-type': 'application/json',\n          accept: 'application/json',\n        },\n      });\n      return  {response: await response.json(), error: null};\n    } catch (error) {\n      return {response: null, error: error};\n    }\n  }\n\n  //return function returns positive number if score1 beats score2, 0 if scores are equal, negative \n  //number otherwise\n  export const scoreComparator = ((scoreDirectionUp, scoreType) => {\n    return function(score1, score2) {\n      debugger;\n      if (scoreType === scoreTypes.POINTS) {\n        return scoreDirectionUp ? score1 - score2 :  score2 - score1;\n      } else {\n        const time1 = score1.replace(' ', '');\n        const time2 = score2.replace(' ', '');\n        return scoreDirectionUp ? time1 - time2 : time2 - time1;   \n      }\n    }\n  });\n\n  //returns a map with key as a date string and value as a Map with key: leagueUser id and \n  // value: the users best score for that date \n  export const getAllDatesWithScore = (league, comparator) => {\n    if (!league) return null;\n    const dates = new Map();\n    const leagueUsers = [...league.leagueUsers];\n    leagueUsers.forEach((leagueUser) => \n    leagueUser.scores.forEach((score) => {\n      if (dates.has(score.date)) {\n        return false;\n      } else {\n        dates.set(score.date, null);\n        return true;\n      }\n   }));\n   leagueUsers.forEach((leagueUser) => {\n      leagueUser.scores.forEach((score) => {\n        let userMap = dates.get(score.date);\n        if (userMap === null) {\n          userMap = new Map();\n          userMap.set(leagueUser.id, score);\n          dates.set(score.date, userMap);\n        } else {\n          const bestScore = userMap.get(leagueUser.id);\n            debugger;\n          if (!bestScore || comparator(score.value, bestScore.value) > 0) {\n            userMap.set(leagueUser.id, score);\n          }\n        }\n     })\n  })\n   return dates;\n  }\n\n//returns foramtted date without adjusting for time zone (date-fns does this automatically)\nexport function formatIgnoreTimeZone(date, formatString) {\n  const dateNew = new Date(date.valueOf() + date.getTimezoneOffset() * 60 * 1000);\n  return format(dateNew, formatString);\n}\n\nexport const scoreTypes = {\n  POINTS : 'points',\n  TIME : 'time',\n};\n\nexport function parseScore(scoreString) {\n  if (!scoreString) return null;\n  const toArr = scoreString.trim().split(' ');\n  if (toArr.length === 1) {\n    return toArr[0];\n  } else if (toArr.length === 2) {\n    return toArr[0] + ':' + toArr[1];\n  }\n  return null;\n}"]},"metadata":{},"sourceType":"module"}